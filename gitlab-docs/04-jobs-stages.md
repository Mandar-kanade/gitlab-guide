# Jobs and Stages

Jobs and stages are the building blocks of GitLab CI/CD pipelines. This document explains how to effectively configure and use them.

## Stages

Stages define groups of jobs that run in sequence. All jobs in a stage run in parallel (if runners are available), and if all jobs in a stage succeed, the pipeline continues to the next stage.

### Defining Stages

Stages are defined at the top level of your `.gitlab-ci.yml` file:

```yaml
stages:
  - build
  - test
  - deploy
```

If no stages are defined, GitLab uses default stages: `.pre`, `build`, `test`, `deploy`, `.post`.

### Stage Execution Order

Stages run in the order defined in your `stages` list. A job without a stage is assigned to the `test` stage by default.

## Jobs

Jobs are the fundamental elements in GitLab CI/CD pipelines. Each job:

- Has a unique name
- Belongs to a stage
- Contains at least one script to execute
- Runs in its own environment (shell or container)
- Can have additional configuration for artifacts, dependencies, rules, etc.

### Job Structure

A basic job looks like this:

```yaml
job-name:
  stage: stage-name
  script:
    - command1
    - command2
  rules:
    - if: condition
      when: always/never/manual
```

### Job Names

Job names must be unique across your pipeline and can only contain letters, digits, spaces, `_`, `-`, `.`, `/`, `$`, and `{}`.

### Script

The `script` section is required for all jobs and defines the commands to run:

```yaml
test-job:
  script:
    - echo "Running tests..."
    - npm test
    - echo "Tests completed!"
```

#### Multi-line Scripts

You can use YAML's multi-line strings for longer scripts:

```yaml
build-job:
  script:
    - |
      echo "Building application..."
      mkdir -p build
      cd build
      cmake ..
      make
      echo "Build completed!"
```

### Before and After Scripts

You can define commands that run before or after each job's main script:

```yaml
default:
  before_script:
    - echo "This runs before all jobs"
    - npm install

some-job:
  before_script:
    - echo "This overrides the default before_script"
  script:
    - npm test
  after_script:
    - echo "This runs after the job, even if it fails"
```

### Job Control Flow

#### Exit Codes

Jobs succeed when all commands in the script exit with code 0 and fail otherwise. You can use shell operators to control this behavior:

```yaml
test-job:
  script:
    - command1 || echo "Command 1 failed but we continue"
    - command2 && echo "Command 2 succeeded"
    - command3; echo "This runs regardless of command3's status"
```

#### Timeouts

You can set timeouts for jobs to prevent them from running indefinitely:

```yaml
long-job:
  script:
    - echo "This is a long-running job"
    - sleep 60
  timeout: 5 minutes
```

## Job Execution Control

### Job Dependencies

Jobs can depend on jobs from previous stages:

```yaml
build-job:
  stage: build
  script:
    - echo "Building..."
    - mkdir -p build
    - touch build/artifact.txt

test-job:
  stage: test
  script:
    - echo "Testing..."
    - test -f build/artifact.txt
  dependencies:
    - build-job
```

### Manual Jobs

Jobs can be configured to run only when manually triggered:

```yaml
deploy-production:
  stage: deploy
  script:
    - echo "Deploying to production..."
  rules:
    - when: manual
  environment:
    name: production
```

### Parallel Jobs

You can run the same job multiple times in parallel with different variables:

```yaml
test-job:
  script:
    - echo "Running tests for $BROWSER"
    - npm test -- --browser=$BROWSER
  parallel:
    matrix:
      - BROWSER: [firefox, chrome, safari]
```

This creates three parallel jobs, one for each browser.

## Job Artifacts

Artifacts are files generated by jobs that get uploaded to GitLab and can be downloaded or used by later jobs.

### Basic Artifact Configuration

```yaml
build-job:
  script:
    - echo "Building..."
    - mkdir -p build
    - echo "Build result" > build/result.txt
  artifacts:
    paths:
      - build/
```

### Artifact Types

GitLab supports different types of artifacts:

```yaml
test-job:
  script:
    - echo "Testing..."
    - mkdir -p reports
    - echo "<test-results>...</test-results>" > reports/junit.xml
  artifacts:
    paths:
      - reports/
    reports:
      junit: reports/junit.xml
```

Common artifact report types include:
- `junit`: Test results (XML format)
- `coverage_report`: Code coverage reports
- `codequality`: Code quality reports
- `sast`: Static Application Security Testing reports
- `dast`: Dynamic Application Security Testing reports
- `performance`: Performance testing reports

### Artifact Expiration

You can set when artifacts expire:

```yaml
build-job:
  script: 
    - echo "Building..."
  artifacts:
    paths:
      - build/
    expire_in: 1 week
```

Valid time units: `seconds`, `minutes`, `hours`, `days`, `weeks`, `months`, `years`.

## Advanced Job Features

### Job Retry

You can configure jobs to retry automatically on failure:

```yaml
flaky-test:
  script:
    - echo "Running flaky tests..."
    - npm test
  retry:
    max: 2
    when:
      - runner_system_failure
      - script_failure
```

### Job Interruptible

Mark jobs as interruptible to save pipeline minutes:

```yaml
long-job:
  script:
    - echo "Long-running job..."
  interruptible: true
```

Interruptible jobs can be canceled if a newer pipeline is started for the same branch.

### Job Environments

Jobs can be associated with deployment environments:

```yaml
deploy-staging:
  script:
    - echo "Deploying to staging..."
  environment:
    name: staging
    url: https://staging.example.com
```

### Job Variables

You can define variables for specific jobs:

```yaml
build-job:
  variables:
    BUILD_TYPE: "release"
  script:
    - echo "Building $BUILD_TYPE version..."
```

## Practical Example

Here's a complete example that shows how jobs and stages work together:

```yaml
stages:
  - build
  - test
  - deploy

variables:
  APP_NAME: "my-awesome-app"

build-app:
  stage: build
  script:
    - echo "Building $APP_NAME..."
    - mkdir -p build
    - echo "Version 1.0" > build/version.txt
    - echo "Build complete!"
  artifacts:
    paths:
      - build/

unit-tests:
  stage: test
  script:
    - echo "Running unit tests..."
    - echo "All tests passed!"
  dependencies:
    - build-app

integration-tests:
  stage: test
  script:
    - echo "Running integration tests..."
    - test -f build/version.txt
    - echo "All integration tests passed!"
  dependencies:
    - build-app

deploy-staging:
  stage: deploy
  script:
    - echo "Deploying to staging..."
    - echo "Deployed $APP_NAME to staging server!"
  environment:
    name: staging
    url: https://staging.example.com
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success

deploy-production:
  stage: deploy
  script:
    - echo "Deploying to production..."
    - echo "Deployed $APP_NAME to production server!"
  environment:
    name: production
    url: https://example.com
  rules:
    - if: '$CI_COMMIT_TAG'
      when: manual
  dependencies:
    - build-app
```

This pipeline:
1. Builds the application and produces artifacts
2. Runs unit and integration tests in parallel (both depending on the build job)
3. Deploys to staging automatically when on the main branch
4. Allows manual deployment to production when a tag is created

## Next Steps

Now that you understand jobs and stages in GitLab CI/CD, let's explore [GitLab Runners](05-runners.md) in more detail. 